Notes on table and buffer io

DONE & TESTED
- table-ref                 (tabr)
- table-set!                (tabs)
- table->vector             (t->v)
- vector-set-from-table!    (vecst)  (vector-set-from-table! vector {vec-index} 'table {index} {count})
- table-set-from-vector!    (tabsv)  (table-set-from-vector! table {table-index} 'vector {index} {count})

TODO:
- table-length              (tabl)  (table-length table)   



- plan for buffers:
- drop the mc/vs single channel shit and copy the js sig

(bufr {buffer-name} {chan} {index})
(bufr {buffer-name} {index}) -> assumes channel 0

(bufs {buffer-name} {chan} {index} {value})
(bufs {buffer} {index} {value}

(buffer->vector {buff} {chan} {start} {count}}
- equivalent in sig and function to js peek
- note than in JS, chan is 1 based counting. do we want to do that??

(buffer-set-from-vector! {buff} {opt-chan} {opt-buff-index} {vector} {opt-index} {opt-count}) 

(vector-set-from-buffer! {vector} {index} {buffer} {chan} {count}

LATER:
(buffer->vector* {buff} {start} {count}) 
  - returns multi-dimensional vector from all channels in the buffer

- returns a vector from a buffer
(vector-set-from-buffer! vector {vstart} {buffer} {chan} {bstart-opt} {count-opt}
(buffer-set-from-vector! buffer {opt-chan} {opt-buff-index} vector {opt-start} {opt-count}) 

- later add multi-dimensional versions to work with multi-dimensional vectors

TO CHECK:

ALSO NEED
- table-length function
- buffer-samples (in samples)
- buffer-channels
